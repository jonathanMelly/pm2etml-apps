<?php
//mainly generated by claude.ai
namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\File;
use Illuminate\Support\Facades\Http;
use Symfony\Component\Finder\Finder;

class ScanI18n extends Command
{
    protected const DEEPL_API_URL = 'https://api-free.deepl.com/v2/translate';
    protected ?string $deeplApiKey = null;
    protected $signature = 'i18n:scan
    {--export : Export untranslated strings to JSON and PHP files}
    {--php-only : Only scan PHP translations (not PHP)}
    {--json-only : Only scan JSON translations (not PHP)}
    {--auto-translate : Automatically translate missing strings using DeepL API}
    {--save : Save auto-translated strings directly to language files}';

    protected $description = 'Scan Blade and PHP files for untranslated i18n strings';

    // Translation patterns to look for
    protected array $patterns = [
        // JSON translations
        'json' => [
            // __('example') - single quotes
            '/__\(\'([^\']+)\'\)/',
            // __("example") - double quotes
            '/__\("([^"]+)"\)/',
            // __('example', [...]) - with parameters - single quotes
            '/__\(\'([^\']+)\'\s*,/',
            // __("example", [...]) - with parameters - double quotes
            '/__\("([^"]+)"\s*,/',
            // @lang('example')
            '/@lang\([\'"]([^\'"]+)[\'"]\)/',
            // trans('example')
            '/trans\([\'"]([^\'"]+)[\'"]\)/',
            // {{ __('example') }}
            '/\{\{\s*__\([\'"]([^\'"]+)[\'"](,[^\)]+)?\)\s*\}\}/',
            // {!! __('example') !!}
            '/\{!!\s*__\([\'"]([^\'"]+)[\'"]\)\s*!!\}/',
            // onclick="....__('example')..." and other HTML attributes
            '/(?:onclick|onchange|onsubmit|data-[a-z-]+)=[\'"][^\'\"]*__\([\'"]([^\'"]+)[\'"]\)[^\'\"]*[\'"]/',
            // onclick="...{{'{{__('example')}}'}}..." - Blade syntax in HTML attributes
            '/(?:onclick|onchange|onsubmit|data-[a-z-]+)=[\'"][^\'\"]*\{\{\s*__\([\'"]([^\'"]+)[\'"]\)\s*\}\}[^\'\"]*[\'"]/',
        ],
        // PHP translations (with dots)
        'php' => [
            // __('auth.failed')
            '/__\([\'"]([a-zA-Z0-9_\-\.]+)[\'"]\)/',
            // trans('auth.failed')
            '/trans\([\'"]([a-zA-Z0-9_\-\.]+)[\'"]\)/',
            // Lang::get('auth.failed')
            '/Lang::get\([\'"]([a-zA-Z0-9_\-\.]+)[\'"]\)/',
            // trans_choice for plural translations
            '/trans_choice\([\'"]([a-zA-Z0-9_\-\.]+)[\'"]\s*,/',
        ]
    ];

    public function handle()
    {
        if ($this->option('auto-translate')) {
            $this->deeplApiKey = env('DEEPL_API_KEY');
            if (!$this->deeplApiKey) {
                $this->error('DEEPL_API_KEY not found in .env file!');
                return 1;
            }
        }
        $this->info('Scanning files for i18n strings...');

        $scanJson = !$this->option('php-only');
        $scanPhp = !$this->option('json-only');

        if ($scanJson) {
            $this->handleJsonTranslations();
        }

        if ($scanPhp) {
            $this->handlePhpTranslations();
        }

        return 0;
    }

    protected function handleJsonTranslations(): void
    {
        // Get current translations from fr.json
        $frTranslations = $this->getFrenchJsonTranslations();

        // Scan files for JSON-style translations
        $usedTranslations = $this->scanFiles($this->patterns['json']);
        
        // Find untranslated strings
        $untranslatedStrings = $this->findUntranslatedJsonStrings($usedTranslations, $frTranslations);

        if (empty($untranslatedStrings)) {
            $this->info('All JSON translations are present in fr.json!');
            return;
        }

        $this->info(count($untranslatedStrings) . ' untranslated JSON strings found:');
        $this->table(
            ['String', 'Files Used In'],
            collect($untranslatedStrings)->map(function($files, $string) {
                return [$string, implode(", ", array_unique($files))];
            })->toArray()
        );

        if ($this->option('auto-translate')) {
            $this->translateAndSaveJsonStrings($untranslatedStrings);
        } elseif ($this->option('export')) {
            $this->exportUntranslatedJsonStrings($untranslatedStrings);
        }
    }

    protected function handlePhpTranslations(): void
    {
        // Get current translations from fr/*.php files
        $frTranslations = $this->getFrenchPhpTranslations();

        // Scan files for PHP-style translations
        $usedTranslations = $this->scanFiles($this->patterns['php']);

        // Find missing translations
        $missingTranslations = $this->findMissingPhpTranslations($usedTranslations, $frTranslations);

        if (empty($missingTranslations)) {
            $this->info('All PHP translations are present in fr/*.php files!');
            return;
        }

        $this->info(count($missingTranslations) . ' missing PHP translations found:');
        $this->table(
            ['Key', 'Files Used In'],
            collect($missingTranslations)->map(function($files, $key) {
                return [$key, implode(", ", array_unique($files))];
            })->toArray()
        );

        if ($this->option('auto-translate')) {
            $this->translateAndSavePhpStrings($missingTranslations);
        } elseif ($this->option('export')) {
            $this->exportMissingPhpTranslations($missingTranslations);
        }
    }

    protected function getFrenchJsonTranslations(): array
    {
        $frFile = lang_path('fr.json');

        if (!File::exists($frFile)) {
            $this->warn('fr.json not found in lang directory. Creating empty file.');
            File::put($frFile, '{}');
            return [];
        }

        $translations = json_decode(File::get($frFile), true);

        if (json_last_error() !== JSON_ERROR_NONE) {
            $this->error('Invalid JSON in fr.json!');
            exit(1);
        }

        return $translations;
    }

    protected function getFrenchPhpTranslations(): array
    {
        $translations = [];
        $frPath = lang_path('fr');

        if (!File::exists($frPath)) {
            $this->warn('fr directory not found in lang directory. Creating it.');
            File::makeDirectory($frPath);
            return [];
        }

        $files = File::files($frPath);
        foreach ($files as $file) {
            $key = basename($file->getFilename(), '.php');
            $content = require $file->getPathname();
            if (is_array($content)) {
                $translations[$key] = $content;
            }
        }

        return $translations;
    }

    protected function scanFiles(array $patterns): array
    {
        $usedTranslations = [];

        $finder = new Finder();
        $files = $finder
            ->files()
            ->in([
                base_path('app'),
                resource_path('views')
            ])
            ->name(['*.php', '*.blade.php'])
            ->notPath('Console/Commands/ScanI18n.php');

        foreach ($files as $file) {
            $content = $file->getContents();
            $relativePath = $file->getRelativePathname();

            foreach ($patterns as $pattern) {
                if (preg_match_all($pattern, $content, $matches)) {
                    foreach ($matches[1] as $match) {
                        // Skip if it's a variable
                        if (str_starts_with($match, '$')) {
                            continue;
                        }

                        if (!isset($usedTranslations[$match])) {
                            $usedTranslations[$match] = [];
                        }
                        $usedTranslations[$match][] = $relativePath;
                    }
                }
            }
        }

        return $usedTranslations;
    }

    protected function findUntranslatedJsonStrings(array $usedTranslations, array $frTranslations): array
    {
        $untranslated = [];

        foreach ($usedTranslations as $string => $files) {
            // Check if this looks like a PHP translation key (has dots that separate words, not punctuation)
            $isPhpTranslationKey = preg_match('/^[a-zA-Z0-9_\-]+\.[a-zA-Z0-9_\-\.]+$/', $string);
            
            // Include strings that are not PHP translation keys and not already translated
            if (!$isPhpTranslationKey && !isset($frTranslations[$string])) {
                $untranslated[$string] = $files;
            }
        }

        return $untranslated;
    }

    protected function findMissingPhpTranslations(array $usedTranslations, array $frTranslations): array
    {
        $missing = [];

        foreach ($usedTranslations as $key => $files) {
            // Only include keys with dots (JSON translations don't use dots)
            if (str_contains($key, '.')) {
                [$file, $translationKey] = explode('.', $key, 2);

                if (!isset($frTranslations[$file]) ||
                    !$this->arrayHasKey($frTranslations[$file], $translationKey)) {
                    $missing[$key] = $files;
                }
            }
        }

        return $missing;
    }

    protected function arrayHasKey(array $array, string $key): bool
    {
        $keys = explode('.', $key);
        $current = $array;

        foreach ($keys as $segment) {
            if (!is_array($current) || !array_key_exists($segment, $current)) {
                return false;
            }
            $current = $current[$segment];
        }

        return true;
    }

    protected function exportUntranslatedJsonStrings(array $untranslatedStrings): void
    {
        $exportPath = storage_path('app/i18n');
        if (!File::exists($exportPath)) {
            File::makeDirectory($exportPath, 0755, true);
        }

        // Create a JSON structure with empty translations
        $export = [];
        foreach ($untranslatedStrings as $string => $files) {
            $export[$string] = ""; // Empty string for translation
        }

        $filename = $exportPath . '/untranslated_json_' . date('Y-m-d_His') . '.json';

        File::put(
            $filename,
            json_encode($export, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE)
        );

        $this->info("Untranslated JSON strings exported to: $filename");
    }

    protected function exportMissingPhpTranslations(array $missingTranslations): void
    {
        $exportPath = storage_path('app/i18n');
        if (!File::exists($exportPath)) {
            File::makeDirectory($exportPath, 0755, true);
        }

        // Group by file
        $byFile = [];
        foreach ($missingTranslations as $key => $files) {
            [$file, $translationKey] = explode('.', $key, 2);
            if (!isset($byFile[$file])) {
                $byFile[$file] = [];
            }
            $byFile[$file][$translationKey] = "";
        }

        // Export each file
        foreach ($byFile as $file => $translations) {
            $filename = $exportPath . '/missing_' . $file . '_' . date('Y-m-d_His') . '.php';

            $content = "<?php\n\nreturn " . var_export($translations, true) . ";\n";
            File::put($filename, $content);

            $this->info("Missing translations for {$file} exported to: $filename");
        }
    }

    protected function translateString(string $text): ?string
    {
        try {
            $response = Http::withOptions([
                'verify' => false  // Disable SSL verification - use with caution
            ])->withHeaders([
                'Authorization' => 'DeepL-Auth-Key ' . $this->deeplApiKey
            ])->post(self::DEEPL_API_URL, [
                'text' => [$text],
                'target_lang' => 'FR',
                'source_lang' => 'EN',
                'preserve_formatting' => true,
            ]);

            if ($response->successful()) {
                return $response->json()['translations'][0]['text'];
            }

            $this->warn("Failed to translate: $text");
            $this->warn("API Error: " . $response->body());
            return null;

        } catch (\Exception $e) {
            $this->warn("Translation error for: $text");
            $this->warn($e->getMessage());
            return null;
        }
    }

    protected function translateAndSaveJsonStrings(array $untranslatedStrings): void
    {
        if (empty($untranslatedStrings)) {
            return;
        }

        $this->info('Translating JSON strings...');
        $translations = [];
        $progressBar = $this->output->createProgressBar(count($untranslatedStrings));

        foreach ($untranslatedStrings as $string => $files) {
            $translation = $this->translateString($string);
            if ($translation) {
                $translations[$string] = $translation;
            }
            $progressBar->advance();
            usleep(100000); // Respect API rate limits
        }

        $progressBar->finish();
        $this->newLine();

        if ($this->option('save')) {
            $frFile = lang_path('fr.json');
            $existing = $this->getFrenchJsonTranslations();
            $merged = array_merge($existing, $translations);

            File::put(
                $frFile,
                json_encode($merged, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES)
            );

            $this->info('Translations saved to fr.json');
        } else {
            // Export to a separate file
            $exportPath = storage_path('app/i18n');
            $filename = $exportPath . '/auto_translated_' . date('Y-m-d_His') . '.json';

            File::put(
                $filename,
                json_encode($translations, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES)
            );

            $this->info("Auto-translated strings exported to: $filename");
        }
    }

    protected function translateAndSavePhpStrings(array $missingTranslations): void
    {
        if (empty($missingTranslations)) {
            return;
        }

        $this->info('Translating PHP strings...');
        $byFile = [];
        $progressBar = $this->output->createProgressBar(count($missingTranslations));

        foreach ($missingTranslations as $key => $files) {
            [$file, $translationKey] = explode('.', $key, 2);

            // Get the English version to translate
            $enFile = lang_path("en/$file.php");
            if (!File::exists($enFile)) {
                continue;
            }

            $enTranslations = require $enFile;
            $textToTranslate = data_get($enTranslations, $translationKey);

            if (is_string($textToTranslate)) {
                $translation = $this->translateString($textToTranslate);
                if ($translation) {
                    if (!isset($byFile[$file])) {
                        $byFile[$file] = [];
                    }
                    data_set($byFile[$file], $translationKey, $translation);
                }
            }

            $progressBar->advance();
            usleep(100000); // Respect API rate limits
        }

        $progressBar->finish();
        $this->newLine();

        if ($this->option('save')) {
            foreach ($byFile as $file => $translations) {
                $frPath = lang_path("fr/$file.php");
                $existing = File::exists($frPath) ? require $frPath : [];
                $merged = array_merge_recursive($existing, $translations);

                if (!File::exists(dirname($frPath))) {
                    File::makeDirectory(dirname($frPath), 0755, true);
                }

                $content = "<?php\n\nreturn " . var_export($merged, true) . ";\n";
                File::put($frPath, $content);
            }

            $this->info('Translations saved to fr/*.php files');
        } else {
            // Export to separate files
            $exportPath = storage_path('app/i18n');
            foreach ($byFile as $file => $translations) {
                $filename = $exportPath . '/auto_translated_' . $file . '_' . date('Y-m-d_His') . '.php';
                $content = "<?php\n\nreturn " . var_export($translations, true) . ";\n";
                File::put($filename, $content);
                $this->info("Auto-translated strings for $file exported to: $filename");
            }
        }
    }
}
